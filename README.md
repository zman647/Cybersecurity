# Cybersecurity
SNHU Cybersecurity
Final Project and Final Project included in this repository

How can I ensure that my code, program, or software is functional and secure?
a. Functionality
Unit Testing: Test each component of your software in isolation to ensure they function as intended.
Integration Testing: Test the interactions between units or components.
System Testing: Test the complete system to ensure it meets the specified requirements.

b. Security
Static Analysis: From research I have done, there are some decent static scanning tools to find a large amount of things quickly
Dynamic Analysis: Conduct dynamic tests to uncover vulnerabilities that don't appear in the code but manifest during execution
Penetration Testing: Many places regularly have security firms test the defenses of your system.
Stay Updated: Regularly update your software libraries and dependencies. Outdated libraries are a common source of vulnerabilities.
Secure Development Practices: Keep updated with current standards to make sure the best security is given.

How do I interpret user needs and incorporate?
Requirement Gathering: Start with discussions, interviews, and surveys with the users.
User Stories: Talks with users to see what is needed and what can be improved upon.
Prototyping: Developing mockups and prototypes of the application. This gives users a good understanding of what they want and also an idea of what you can improve.
Feedback Loops: Be sure there are feedback loops. 
User Acceptance Testing: Before final release, have actual users test the product.

How do I approach designing software? 
Understand the Problem: Before you start coding, understand what you need and want. Talk and collaborate with others.
Design Principles: MAKE SURE THE SOFTWARE IS MAINTAINABLE AND SCALABLE.
Design Patterns: There are many programs made already, you can build of of those and use other experiences to your advantage.
Modeling: Use UML models to visully represent the software.
Design: Prepare to go back sometimes and fix/change code to make it more efficient.
Documentation: Document all design decisions and components, along with interactions and why you made those decisions. This helps yourself and future developers.
